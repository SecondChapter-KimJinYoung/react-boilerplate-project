# ─────────────────────────────────────────────────────
# CI/CD Pipeline
#
# 트리거 조건:
#   - main 브랜치에 push (배포까지 실행)
#   - main 대상 PR 생성/업데이트 (품질 검사 + 빌드만)
#   - 수동 실행 (workflow_dispatch)
#
# 실행 흐름:
#   install → quality (병렬) → build → deploy (main push만)
#           → test   (병렬) ↗       → bundle-report (항상)
#
# 각 job은 독립된 러너(가상머신)에서 실행되므로
# 이전 job의 파일을 자동으로 접근할 수 없음
# → 캐시와 아티팩트로 job 간 데이터를 공유함
# ─────────────────────────────────────────────────────
name: CI/CD

on:
  push:
    branches: [main] # main에 머지/push 되면 → 전체 파이프라인 (배포 포함)
  pull_request:
    branches: [main] # main 대상 PR 열림/업데이트 → 검사 + 빌드만 (배포 안 함)
  workflow_dispatch: # Actions 탭에서 수동 실행 버튼

# 같은 브랜치에서 연속 push 시 이전 워크플로우를 자동 취소
# 예: PR에 커밋 3개를 빠르게 push하면 마지막 것만 실행됨
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# 최소 권한 원칙 (Least Privilege)
# 기본은 코드 읽기만 허용하고, 추가 권한이 필요한 job에서만 개별 선언
# → bundle-report: pull-requests: write (PR 코멘트 작성)
# → deploy: statuses: write (커밋 상태 ✅❌ 표시)
permissions:
  contents: read

jobs:
  # ─────────────────────────────────────────────────────
  # 1단계: 의존성 설치 + 캐시 생성
  #
  # 이 job이 하는 일:
  #   1) 코드 체크아웃
  #   2) Node.js 20 설치 + Yarn Modern 활성화
  #   3) yarn install로 node_modules 생성
  #   4) node_modules를 GitHub 캐시에 저장
  #
  # 이후 quality, test, build job들은
  # 이 캐시를 복원해서 yarn install 없이 바로 실행함
  # → 전체 파이프라인에서 install은 딱 한 번만 수행됨
  # ─────────────────────────────────────────────────────
  install:
    name: Install Dependencies
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Corepack을 setup-node보다 먼저 활성화해야 함
      # setup-node가 cache: 'yarn' 처리 시 yarn 경로를 조회하는데
      # packageManager: "yarn@4.12.0"을 인식하려면 Corepack이 필요
      - name: Enable Corepack
        run: corepack enable

      - uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn' # yarn 글로벌 캐시(.yarn/cache)도 자동 캐싱

      # --immutable: yarn.lock과 실제 설치 결과가 다르면 에러
      # CI에서 lock 파일 무결성을 강제하여 "내 로컬에선 됐는데" 방지
      - name: Install
        run: yarn install --immutable

      # 설치된 패키지에 알려진 보안 취약점(CVE)이 있는지 검사
      # --severity high: CVSS 7.0 이상(high/critical)만 검출
      # → moderate/low까지 잡으면 false positive가 많아 개발 방해
      # 데이터 출처: GitHub Advisory Database (NVD/MITRE 기반)
      # 여기서 실패하면 이후 quality/test/build가 전부 스킵됨
      - name: Security audit
        run: yarn npm audit --severity high

      # 캐시 키: yarn.lock의 해시값 기반
      # yarn.lock이 동일하면 → 캐시 히트 → 다음 job에서 install 생략
      # yarn.lock이 변경되면 → 캐시 미스 → 새로 install 후 캐시 갱신
      - name: Save node_modules cache
        uses: actions/cache/save@v4
        with:
          path: node_modules
          key: nm-${{ runner.os }}-${{ hashFiles('yarn.lock') }}

  # ─────────────────────────────────────────────────────
  # 2단계-A: 품질 검사 (병렬 실행)
  #
  # matrix 전략으로 3개의 검사를 각각 별도 러너에서 동시 실행:
  #   - Type Check: TypeScript 타입 오류 검사
  #   - Lint: ESLint 코드 품질/스타일 검사
  #   - Format: Prettier 포맷팅 규칙 준수 여부
  #
  # fail-fast: false
  #   → 하나가 실패해도 나머지는 계속 실행
  #   → 한 번의 CI 실행으로 모든 문제를 확인 가능
  #   (true면 하나 실패 시 나머지도 즉시 취소됨)
  # ─────────────────────────────────────────────────────
  quality:
    name: Quality (${{ matrix.check.name }})
    runs-on: ubuntu-latest
    needs: install # install 완료 후 실행
    strategy:
      fail-fast: false
      matrix:
        check:
          - { name: Type Check, command: type-check }
          - { name: Lint, command: lint }
          - { name: Format, command: 'format:check' }
    steps:
      # checkout을 먼저 해야 로컬 composite action 파일을 참조할 수 있음
      - uses: actions/checkout@v4
      # composite action: corepack → setup-node → 캐시 복원
      # 이 한 줄로 install job이 저장한 node_modules를 복원함
      - uses: ./.github/actions/setup

      - name: ${{ matrix.check.name }}
        run: yarn ${{ matrix.check.command }}

  # ─────────────────────────────────────────────────────
  # 2단계-B: 테스트 (quality와 동시에 병렬 실행)
  #
  # quality와 같은 needs: install을 가지므로
  # install 완료 후 quality 3개 + test 1개 = 총 4개가 동시 실행됨
  #
  # 사전 준비 (프로젝트에서 한 번만 하면 됨):
  #   yarn add -D vitest @testing-library/react @testing-library/jest-dom jsdom
  #   vite.config.ts에 test 설정 추가
  #   package.json에 "test": "vitest run" 스크립트 추가
  #
  # 테스트 작성 우선순위:
  #   1순위: 핵심 비즈니스 로직 (계산, 유효성 검증 등 순수 함수)
  #   2순위: 주요 유저 플로우 (로그인, 핵심 CRUD)
  #   3순위: 나머지 (여유 될 때 점진적으로 확장)
  # ─────────────────────────────────────────────────────
  test:
    name: Test
    runs-on: ubuntu-latest
    needs: install
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup

      # --coverage: 테스트 실행 후 coverage/ 디렉토리에 커버리지 리포트 생성
      # 이 step이 실패하면 build job으로 진행 불가 → 배포 차단
      - name: Run tests
        run: yarn test --coverage

      # if: always() → 테스트가 실패하더라도 커버리지 리포트는 업로드
      # Actions 탭 → Artifacts에서 다운로드하여
      # 어떤 파일의 어떤 라인이 테스트 안 됐는지 확인 가능
      - name: Upload coverage
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: coverage-report
          path: coverage/

  # ─────────────────────────────────────────────────────
  # 3단계: 프로덕션 빌드
  #
  # needs: [quality, test]
  #   → quality 3개 + test 1개 총 4개 job이 모두 통과해야 실행
  #   → 하나라도 실패하면 빌드 자체가 실행되지 않음
  #   → 빌드가 안 되면 deploy도 안 됨 (자연스럽게 배포 차단)
  #
  # 빌드 결과물(dist/)은 아티팩트로 업로드하여
  # deploy job과 bundle-report job에서 다운로드해 사용함
  # (job마다 별도 러너이므로 파일 시스템을 공유하지 않기 때문)
  # ─────────────────────────────────────────────────────
  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [quality, test]
    steps:
      - uses: actions/checkout@v4
      - uses: ./.github/actions/setup

      # VITE_API_URL: GitHub Secrets에 저장된 API 서버 주소
      # 빌드 시점에 환경변수로 주입되어 번들에 포함됨
      - name: Build
        run: yarn build
        env:
          VITE_API_URL: ${{ secrets.API_URL }}

      # 빌드 결과물을 GitHub 아티팩트로 업로드
      # retention-days: 7 → 7일 후 자동 삭제 (스토리지 절약)
      # deploy job과 bundle-report job에서 download하여 재사용
      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: dist
          retention-days: 7

      # gzip 압축 후 사이즈 측정
      # raw 사이즈가 아닌 실제 네트워크 전송 크기를 기준으로 함
      # (nginx 등 웹서버가 gzip 압축하여 전달하기 때문)
      #
      # main 브랜치에서만 실행: 이 값이 PR의 비교 기준(baseline)이 됨
      # 결과를 bundle-size.json으로 저장 → 캐시에 보관
      - name: Measure baseline bundle size
        if: github.ref == 'refs/heads/main'
        run: |
          JS_BYTES=$(find dist -name '*.js' -exec cat {} + | gzip -c | wc -c)
          CSS_BYTES=$(find dist -name '*.css' -exec cat {} + | gzip -c | wc -c)
          TOTAL_BYTES=$(tar cf - dist | gzip -c | wc -c)
          echo "{\"js\":$JS_BYTES,\"css\":$CSS_BYTES,\"total\":$TOTAL_BYTES}" > bundle-size.json

      # 캐시 키에 commit SHA 포함 → 커밋마다 고유한 baseline 생성
      - name: Save baseline cache
        if: github.ref == 'refs/heads/main'
        uses: actions/cache/save@v4
        with:
          path: bundle-size.json
          key: bundle-baseline-${{ github.sha }}

  # ─────────────────────────────────────────────────────
  # 번들 사이즈 리포트 (gzip 기준)
  #
  # PR과 main push 모두에서 실행되며:
  #   - PR: main 브랜치 baseline 대비 증감을 PR 코멘트로 작성
  #   - main push: Actions 탭 Step Summary에 기록
  #
  # 동작 흐름:
  #   1) build job이 올린 dist 아티팩트 다운로드
  #   2) 캐시에서 main 브랜치의 baseline 사이즈 복원
  #   3) 현재 빌드의 gzip 사이즈 측정
  #   4) baseline과 비교하여 diff 계산 (+12KB, -3KB 등)
  #   5) PR이면 코멘트로 작성, 아니면 Step Summary에 기록
  #
  # baseline이 없으면 (첫 실행 등) diff 없이 현재 사이즈만 표시
  # ─────────────────────────────────────────────────────
  bundle-report:
    name: Bundle Size Report
    runs-on: ubuntu-latest
    needs: build
    permissions:
      pull-requests: write # PR에 코멘트를 달기 위한 권한
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: dist

      # restore-keys의 prefix 매칭으로 가장 최근 main 빌드의 캐시를 가져옴
      # 예: bundle-baseline-abc123, bundle-baseline-def456 중 최신 것
      - name: Restore baseline
        id: baseline
        uses: actions/cache/restore@v4
        with:
          path: bundle-size.json
          key: bundle-baseline-
          restore-keys: bundle-baseline-

      - name: Analyze bundle size
        id: bundle
        run: |
          # 현재 빌드의 gzip 사이즈 측정
          JS_BYTES=$(find dist -name '*.js' -exec cat {} + | gzip -c | wc -c)
          CSS_BYTES=$(find dist -name '*.css' -exec cat {} + | gzip -c | wc -c)
          TOTAL_BYTES=$(tar cf - dist | gzip -c | wc -c)
          ASSET_COUNT=$(find dist/assets -type f | wc -l)

          # 바이트 → 사람이 읽기 쉬운 단위(KB/MB)로 변환
          format_bytes() {
            if [ "$1" -ge 1048576 ]; then
              echo "$(awk "BEGIN{printf \"%.1f\", $1/1048576}")MB"
            else
              echo "$(awk "BEGIN{printf \"%.1f\", $1/1024}")KB"
            fi
          }

          # baseline 캐시가 존재하면 diff 계산
          if [ -f bundle-size.json ]; then
            BASE_JS=$(jq '.js' bundle-size.json)
            BASE_CSS=$(jq '.css' bundle-size.json)
            BASE_TOTAL=$(jq '.total' bundle-size.json)

            # 증가면 +, 감소면 -, 동일하면 "no change"
            diff_with_sign() {
              local diff=$(( $1 - $2 ))
              if [ "$diff" -gt 0 ]; then
                echo "+$(format_bytes $diff)"
              elif [ "$diff" -lt 0 ]; then
                echo "-$(format_bytes ${diff#-})"
              else
                echo "no change"
              fi
            }

            JS_DIFF=$(diff_with_sign $JS_BYTES $BASE_JS)
            CSS_DIFF=$(diff_with_sign $CSS_BYTES $BASE_CSS)
            TOTAL_DIFF=$(diff_with_sign $TOTAL_BYTES $BASE_TOTAL)
          else
            JS_DIFF="(no baseline)"
            CSS_DIFF="(no baseline)"
            TOTAL_DIFF="(no baseline)"
          fi

          # GITHUB_OUTPUT으로 내보내면 이후 step에서
          # ${{ steps.bundle.outputs.total }} 형태로 참조 가능
          echo "total=$(format_bytes $TOTAL_BYTES)" >> "$GITHUB_OUTPUT"
          echo "js=$(format_bytes $JS_BYTES)" >> "$GITHUB_OUTPUT"
          echo "css=$(format_bytes $CSS_BYTES)" >> "$GITHUB_OUTPUT"
          echo "assets=$ASSET_COUNT" >> "$GITHUB_OUTPUT"
          echo "total_diff=$TOTAL_DIFF" >> "$GITHUB_OUTPUT"
          echo "js_diff=$JS_DIFF" >> "$GITHUB_OUTPUT"
          echo "css_diff=$CSS_DIFF" >> "$GITHUB_OUTPUT"

          # GITHUB_STEP_SUMMARY: Actions 탭 하단에 마크다운 테이블로 표시
          echo "### Bundle Size Report (gzip)" >> "$GITHUB_STEP_SUMMARY"
          echo "| Metric | Size (gzip) | vs main |" >> "$GITHUB_STEP_SUMMARY"
          echo "|--------|-------------|---------|" >> "$GITHUB_STEP_SUMMARY"
          echo "| Total | $(format_bytes $TOTAL_BYTES) | $TOTAL_DIFF |" >> "$GITHUB_STEP_SUMMARY"
          echo "| JS | $(format_bytes $JS_BYTES) | $JS_DIFF |" >> "$GITHUB_STEP_SUMMARY"
          echo "| CSS | $(format_bytes $CSS_BYTES) | $CSS_DIFF |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Assets | $ASSET_COUNT files | - |" >> "$GITHUB_STEP_SUMMARY"

      # PR일 때만 코멘트 작성
      # 이미 봇이 작성한 "Bundle Size Report" 코멘트가 있으면 업데이트
      # 없으면 새로 작성 → PR에 코멘트가 중복으로 쌓이지 않음
      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const body = [
              '### Bundle Size Report (gzip)',
              '| Metric | Size (gzip) | vs main |',
              '|--------|-------------|---------|',
              `| Total | \`${{ steps.bundle.outputs.total }}\` | ${{ steps.bundle.outputs.total_diff }} |`,
              `| JS | \`${{ steps.bundle.outputs.js }}\` | ${{ steps.bundle.outputs.js_diff }} |`,
              `| CSS | \`${{ steps.bundle.outputs.css }}\` | ${{ steps.bundle.outputs.css_diff }} |`,
              `| Assets | \`${{ steps.bundle.outputs.assets }} files\` | - |`,
            ].join('\n');

            // 기존 봇 코멘트 검색
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            const existing = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes('Bundle Size Report')
            );
            const params = {
              owner: context.repo.owner,
              repo: context.repo.repo,
              body,
            };
            // 기존 코멘트가 있으면 업데이트, 없으면 새로 생성
            if (existing) {
              await github.rest.issues.updateComment({ ...params, comment_id: existing.id });
            } else {
              await github.rest.issues.createComment({ ...params, issue_number: context.issue.number });
            }

  # ─────────────────────────────────────────────────────
  # 4단계: 프로덕션 배포
  #
  # 실행 조건 (모두 충족해야 실행):
  #   - main 브랜치에 push일 때만 (PR에서는 실행 안 됨)
  #   - DEPLOY_ENABLED 변수가 'true'일 때만
  #   - SERVER_HOST secret이 등록되어 있을 때만
  #     → 배포 서버가 준비되면 변수 + Secrets 추가하면 자동 활성화
  #
  # timeout-minutes: 10 → 10분 초과 시 자동 실패 처리
  #
  # 배포 흐름:
  #   1) CI 러너에서 빌드된 dist 아티팩트 다운로드
  #   2) SSH로 서버 접속 → 현재 dist를 백업 (롤백 대비)
  #   3) SCP로 새 dist를 서버에 전송
  #   4) nginx 컨테이너 재시작
  #   5) 헬스체크 (3초 간격, 최대 10회 = 30초)
  #   6) 헬스체크 실패 시 → 백업으로 자동 롤백 → nginx 재시작
  #
  # 서버에서 다시 빌드하지 않고 CI에서 빌드한 결과물을 그대로 전송
  # → 빌드 환경 차이로 인한 문제 방지 (빌드 일관성 보장)
  # ─────────────────────────────────────────────────────
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: build
    if: >-
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      vars.DEPLOY_ENABLED == 'true' &&
      secrets.SERVER_HOST != ''
    timeout-minutes: 10
    permissions:
      statuses: write # Notify on failure step에서 커밋 상태 업데이트에 필요
    environment:
      name: production
    steps:
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: dist

      # 현재 서버에 배포된 dist를 타임스탬프 이름으로 백업
      # 최근 3개만 유지하고 나머지는 삭제 (디스크 절약)
      - name: Backup current deployment
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true # 스크립트 중 에러 발생 시 즉시 중단
          script: |
            set -euo pipefail
            DEPLOY_DIR="/home/deploy/frontend"
            if [ -d "$DEPLOY_DIR/dist" ]; then
              cp -r "$DEPLOY_DIR/dist" "/home/deploy/frontend-backup-$(date +%Y%m%d%H%M%S)"
              echo "Backup created"
            fi
            # 오래된 백업 정리: 최신 3개만 남기고 삭제
            ls -dt /home/deploy/frontend-backup-* 2>/dev/null | tail -n +4 | xargs rm -rf

      # SCP(Secure Copy)로 빌드 결과물을 서버에 전송
      # SSH 키 기반 인증으로 비밀번호 없이 파일 복사
      - name: Upload dist to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          source: 'dist/*'
          target: '/home/deploy/frontend'
          overwrite: true

      # 배포 후 서비스가 정상 동작하는지 확인
      # curl로 HTTP 200 응답을 확인하며, 30초간 최대 10번 시도
      # 실패 시 방금 만든 백업으로 자동 복구
      - name: Restart and health check
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          script_stop: true
          script: |
            set -euo pipefail
            HEALTH_URL="http://localhost:3000"
            BACKUP_DIR=$(ls -dt /home/deploy/frontend-backup-* 2>/dev/null | head -1)

            cd /home/deploy
            docker compose restart frontend

            # 3초 간격으로 10번 헬스체크 시도 (최대 30초 대기)
            for i in $(seq 1 10); do
              if curl -sf --max-time 3 "$HEALTH_URL" > /dev/null 2>&1; then
                echo "Deployment successful at $(date)"
                exit 0
              fi
              echo "Health check attempt $i/10..."
              sleep 3
            done

            # 헬스체크 10번 모두 실패 → 자동 롤백
            echo "Health check failed - rolling back"
            if [ -n "$BACKUP_DIR" ] && [ -d "$BACKUP_DIR" ]; then
              rm -rf /home/deploy/frontend/dist
              cp -r "$BACKUP_DIR" /home/deploy/frontend/dist
              docker compose restart frontend
              echo "Rolled back to $BACKUP_DIR"
            fi
            exit 1       # 롤백 후에도 실패로 처리 → GitHub에 실패 상태 전파

      # 배포 실패 시 해당 커밋에 실패 상태를 표시
      # GitHub UI에서 커밋 옆에 빨간 X로 표시됨
      - name: Notify on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.repos.createCommitStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              sha: context.sha,
              state: 'failure',
              description: 'Production deployment failed',
              context: 'deploy/production',
            });
